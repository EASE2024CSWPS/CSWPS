public boolean get rollback only ( ) { local transaction coordinator l coord = get local coord ( ) ; if ( l coord != null ) { return ( l coord . get rollback only ( ) ) ; } else { int status = status . status no transaction ; try { status = tx service . get status ( ) ; } catch ( system exception e ) { ffdc filter . process exception ( e , class name + ".get rollback only" , "667" , this ) ; } return ( status == status . status marked rollback || status == status . status rolledback || status == status . status rolling back ) ; } }
private boolean is cdi enabled ( collection < web sphere bean deployment archive > bdas ) { boolean any has beans = false ; for ( web sphere bean deployment archive bda : bdas ) { boolean has beans = false ; if ( bda . get type ( ) != archive type . runtime extension ) { has beans = is cdi enabled ( bda ) ; } any has beans = any has beans || has beans ; if ( any has beans ) { break ; } } return any has beans ; }
@ override public void set keep messages ( boolean keep messages ) { faces context faces context = faces context . get current instance ( ) ; external context external context = faces context . get external context ( ) ; map < string , object > request map = external context . get request map ( ) ; request map . put ( flash keep messages , keep messages ) ; }
private static boolean is symbolic link ( final file file , file parent file ) throws privileged action exception { file canonical parent dir = get canonical file ( parent file ) ; file file in canonical parent dir = new file ( canonical parent dir , file . get name ( ) ) ; file canonical file = get canonical file ( file in canonical parent dir ) ; return ! canonical file . equals ( file in canonical parent dir . get absolute file ( ) ) ; }
@ ffdc ignore ( illegal argument exception . class ) private ldap search scope evaluate group search scope ( boolean immediate only ) { try { return el helper . process ldap search scope ( "group search scope expression" , this . id store definition . group search scope expression ( ) , this . id store definition . group search scope ( ) , immediate only ) ; } catch ( illegal argument exception e ) { if ( trace component . is any tracing enabled ( ) && tc . is warning enabled ( ) ) { tr . warning ( tc , "javaeesec warning idstore config" , new object [ ] { "group search scope/group search scope expression" , " ldap search scope." subtree } ) ; } return ldap search scope . subtree ; } }
public static sql exception to sql exception ( throwable ex ) { if ( ex == null ) return null ; if ( ex instanceof sql exception ) return ( sql exception ) ex ; if ( ex instanceof resource exception ) return to sql exception ( ( resource exception ) ex ) ; sql exception sql x = new sql exception ( ex . get class ( ) . get name ( ) + ": " + ex . get message ( ) ) ; sql x . init cause ( ex ) ; return sql x ; }
@ override public synchronized void post invoke ( int id , ejs deployed support s ) throws remote exception { super . post invoke ( id , s ) ; final boolean is trace on = trace component . is any tracing enabled ( ) ; if ( is trace on && tc . is entry enabled ( ) ) { tr . entry ( tc , "post invoke" ) ; } if ( iv sf failover client != null ) { if ( iv container tx == null ) { iv container tx = container . get current container tx ( ) ; } container as container as = iv container tx . get container as ( ) ; if ( container as == null ) { if ( iv container tx . is bmt active ( s . method info ) ) { iv sf failover client . sticky uow ( bean id , true ) ; } else { iv sf failover client . sticky uow ( bean id , false ) ; } } else { if ( container as . is bmas active ( s . method info ) ) { iv sf failover client . sticky uow ( bean id , true ) ; } else { iv sf failover client . sticky uow ( bean id , false ) ; } } } if ( is trace on && tc . is entry enabled ( ) ) { tr . exit ( tc , "post invoke" ) ; } }
private synchronized boolean msg can be sent ( long stamp , boolean nack msg ) { if ( trace component . is any tracing enabled ( ) && tc . is entry enabled ( ) ) sib tr . entry ( this , tc , "msg can be sent" , new object [ ] { long . value of ( stamp ) , boolean . value of ( nack msg ) , long . value of ( first msg outside window ) , boolean . value of ( contains guesses ) } ) ; boolean send message = true ; if ( ( stamp >= first msg outside window ) || ( contains guesses && ! nack msg ) ) { send message = false ; if ( trace component . is any tracing enabled ( ) && tc . is debug enabled ( ) ) { sib tr . debug ( tc , "first msg outside window is: " + first msg outside window + " send window is " + send window + " contains guesses is " + contains guesses ) ; } } if ( trace component . is any tracing enabled ( ) && tc . is entry enabled ( ) ) sib tr . exit ( tc , "msg can be sent" , boolean . value of ( send message ) ) ; return send message ; }
void restore dynacache provider defaults ( ) { if ( restore dynacache defaults ) { if ( cache provider name != cache config . cache provider dynacache ) { cache provider name = cache config . cache provider dynacache ; enable cache replication = false ; if ( tc . is debug enabled ( ) ) { tr . debug ( tc , " overriding object grid default for " + cache name ) ; } } } }
protected synchronized void reset ( connection connection , receive listener listener , ws byte buffer data , int size , int segment type , int request number , int priority , boolean allocated from pool , boolean part of exchange , conversation conversation ) { if ( trace component . is any tracing enabled ( ) && tc . is entry enabled ( ) ) sib tr . entry ( this , tc , "reset" , new object [ ] { connection , listener , data , "" + size , "" + segment type , "" + request number , "" + priority , "" + allocated from pool , "" + part of exchange , conversation } ) ; this . connection = connection ; this . listener = listener ; this . data = data ; this . size = size ; this . segment type = segment type ; this . request number = request number ; this . priority = priority ; this . allocated from pool = allocated from pool ; this . part of exchange = part of exchange ; this . conversation = conversation ; set dispatchable ( null ) ; if ( trace component . is any tracing enabled ( ) && tc . is entry enabled ( ) ) sib tr . exit ( this , tc , "reset" ) ; }
